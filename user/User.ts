import { Auth, getAuth, GoogleAuthProvider, signInWithPopup, signInWithEmailAndPassword, setPersistence, inMemoryPersistence, createUserWithEmailAndPassword, updateEmail, updatePassword, deleteUser, reauthenticateWithCredential, EmailAuthProvider, sendPasswordResetEmail, sendEmailVerification } from "@firebase/auth";
import { addDoc, collection, getDoc, getFirestore, serverTimestamp, setDoc, updateDoc, deleteDoc, where, arrayUnion } from "@firebase/firestore";
import { doc, getDocs, orderBy, query } from "firebase/firestore";
import { ImageModel, InfoModel, UserImageModel } from "./../../../_metronic/helpers";

import { SessionHandler, SessionKeys } from '../system/SessionHandler';
import { Utils } from "../system/Utils";
import { ProfileModel } from "./Profile";
import { FileHandler } from "../system/FileHandler";
import { Chat } from "../chat/Chat";
import { Count, CountTypes } from "./Count";
import { Mail } from "../system/Mail";
import { Presence } from "../system/Presence";
import { HttpsActionNames, HttpsHandler } from "../system/HttpsHandler";
import { Analytics, AnalyticsId } from "../system/Analytics";
import { useDispatch } from "react-redux";

export class UserModel extends InfoModel
{
  uuid:string = "";
  token:string = "";
  email:string = "";
  publicPhotos: UserImageModel[] = [];
  privatePhotos: UserImageModel[] = [];
  userType: 'user' | 'chatter' | 'admin' | 'profile_creator' = 'user';
  credits: number = 0;
  profile:ProfileModel = null as any;
  siteOfOrigin:string = "";
  likedProfiles: string[];
  profilesLikedYou: string[];
  availedDiscounts: string[];
  verificationRewardsReceived: boolean = false;
  hasLoggedInBefore: boolean = false;
  geolocation: Map<string, string> = null as any;
  isPaidUser: boolean = false;
  isTestAccount: boolean = false;
  isAutoGenerated: boolean = false;
  isProfileCompleted:boolean = false;
  isDeleted:boolean = false;
  
  constructor(params:any)
  {
    super(params);
    this.uuid = params.uuid;
    this.token = params.token;
    this.email = params.email;
    this.publicPhotos = params.publicPhotos;
    this.privatePhotos = params.privatePhotos;
    this.profile = params.profile;
    this.userType = params.userType;
    this.credits = params.credits;
    this.siteOfOrigin = params.siteOfOrigin;
    this.likedProfiles = params.likedProfiles;
    this.profilesLikedYou = params.profilesLikedYou;
    this.availedDiscounts = params.availedDiscounts;
    this.verificationRewardsReceived = params.verificationRewardsReceived;
    this.hasLoggedInBefore = params.hasLoggedInBefore;
    this.geolocation = params.geolocation;
    this.isPaidUser = params.isPadUser;
    this.isTestAccount = params.isTestAccount;
    this.isAutoGenerated = params.isAutoGenerated;
    this.isProfileCompleted = params.isProfileCompleted;
    this.isDeleted = params.isDeleted;
  }
}

export class UserTypes
{
  public static get TYPE_USER(): string { return "user"; }
  public static get TYPE_CHATTER(): string { return "chatter"; }
  public static get TYPE_ADMIN(): string { return "admin"; }
  public static get TYPE_PROFILE_CREATOR(): string { return "profile_creator";}
}

export class UserTag
{
  public static get NEW_MESSAGE(): string { return "New Message"; }
  public static get LIKED_PROFILE(): string { return "Liked Profile"; }
  public static get LOGGED_IN(): string { return "Logged In"; }
  public static get LOGGED_OUT(): string { return "Logged Out"; }
  public static get NEW_USER(): string { return "New User"; }
  public static get CLICKED_GET_CREDITS(): string { return "Clicked Get Credits"; }
  public static get COMPLETED_PROFILE() : string { return "Completed Profile"; }
  public static get UPLOADED_NEW_PROFILE_PIC() : string { return "Uploaded New Profile Pic"; }
  public static get SUPPORT() : string {return "SUPPORT"}
}

export class User
{
  private static userModel: UserModel = null as any;
  private static isLoggedIn = false;

  private static BASE_USER_IMAGE_DIRECTORY: string = "";
  private static PRIVATE_IMAGES_PATH = "private";
  private static PUBLIC_IMAGES_PATH = "public";
  private static PROFILE_PHOTO_PATH = "profile";

  public static async Initialize(): Promise<void> {
    const auth = getAuth();
    let sessionModel: UserModel = SessionHandler.GetItem<UserModel>(SessionKeys.SESSION_USER_MODEL, null as any);
    //auth.signOut();
    // // console.log(auth, sessionModel)
    if (sessionModel && !sessionModel?.isDeleted) {
      this.userModel = sessionModel;
      this.isLoggedIn = true;
      this.BASE_USER_IMAGE_DIRECTORY = `images/users/${this.userModel.uuid}`
      // console.log(`Uuid: ${sessionModel.uuid} | Name: ${sessionModel.displayName} | RR: ${sessionModel.verificationRewardsReceived}`);
    } else {
      const user =!sessionModel?.isDeleted ?  auth.currentUser : false;
      if (user) {
        await this.GetUserAccount(user.uid).then((model) => {
          if (model) {
            this.userModel = model;
            this.BASE_USER_IMAGE_DIRECTORY = `images/users/${this.userModel.uuid}`
            this.isLoggedIn = true;
          }
        });
      } else {
        this.SignOut();
      }
    }
    
    return Promise.resolve();
  }

  static get Model(): UserModel {
    return this.userModel
  }

  public static SetUserImages(images: UserImageModel[], imageType: string)
  {
    switch (imageType)
    {
      case "private":
        this.userModel.privatePhotos = images;
        break;
      case "public":
        this.userModel.publicPhotos = images;
        break;
    }
  }

  public static async SetHasLoggedInBefore(loggedInBefore: boolean): Promise<void>
  {
    const firestore = getFirestore();
    let userDoc = doc(firestore, "users", this.userModel?.uuid);

    let params = {
      hasLoggedInBefore: loggedInBefore
    }

    let success = false;
    await updateDoc(userDoc, params).then(() => {
      success = true;
    })

    if (success)
      return Promise.resolve();
    else
      return Promise.reject();
  }

  public static async AddProfileDetailsToUserPreferences(profile: ProfileModel): Promise<void>
  {
    const firestore = getFirestore();
    let userDoc = doc(firestore, "users", this.userModel?.uuid);

    let params = {
      ageOfChattedProfiles: arrayUnion(profile.age),
      raceOfChattedProfiles: arrayUnion(profile.ethnicity),
    }

    let success = false;
    await updateDoc(userDoc, params).then(() => {
      success = true;
    })

    if (success)
      return Promise.resolve();
    else
      return Promise.reject();
  }

  public static async MarkUserAsPaidUser(isPaidUser: boolean): Promise<void>
  {
    const firestore = getFirestore();
    let userDoc = doc(firestore, "users", this.userModel?.uuid);
    this.userModel.isPaidUser = isPaidUser;

    let params = {
      isPaidUser: isPaidUser
    }

    let success = false;
    await updateDoc(userDoc, params).then(() => {
      success = true;
    });

    if (success)
      return Promise.resolve();
    else
      return Promise.reject();
  }

  public static get IsLoggedIn(): boolean {
    return this.isLoggedIn && this.userModel != null && this.userModel.uuid !== "";
  }

  public static async SignIn(loginByEmail: boolean, onSuccess: () => void | null, onFail: () => void | null, email: string = "", password: string = ""): Promise<void> {
    const auth = getAuth();
    if (loginByEmail) {
      await this.SignInWithEmailAndPassword(auth, email, password, onSuccess, onFail);
    } else {
      await this.SignInWithGoogle(auth, onSuccess, onFail);
    }
  }

  private static async SignInWithEmailAndPassword(auth: Auth, email: string, password: string, onSuccess: () => void | null, onFail: () => void | null): Promise<void> {
    await signInWithEmailAndPassword(auth, email, password).then(async (userCredential) => {
      // Signed in 
      const user = userCredential.user;
      await this.GetUserAccount(user.uid).then((result) => {
        this.userModel = result;
      })

      onSuccess();
      this.isLoggedIn = true;
      SessionHandler.SetItem(SessionKeys.SESSION_USER_MODEL, this.userModel);
      // onSuccess();
    })
      .catch((error) => {
        const errorCode = error.code;
        const errorMessage = error.message;

        this.isLoggedIn = false;
        onFail();
      });
  }

  private static async SignInWithGoogle(auth: Auth, onSuccess: () => void | null, onFail: () => void | null): Promise<void> {
    const provider = new GoogleAuthProvider();
    await signInWithPopup(auth, provider).then(async (result) => {
      // This gives you a Google Access Token. You can use it to access the Google API.
      //const credential = GoogleAuthProvider.credentialFromResult(result);
      // The signed-in user info.
      const user = result.user;

      await this.GetUserAccount(user.uid).then((result) => {
        this.userModel = result;
      })

      SessionHandler.SetItem(SessionKeys.SESSION_USER_MODEL, this.userModel);
      this.isLoggedIn = true;
      onSuccess();
      // ...
    }).catch((error) => {
      // Handle Errors here.
      //const errorCode = error.code;
      //const errorMessage = error.message;
      // The email of the user's account used.
      //const email = error.email;
      // The AuthCredential type that was used.
      //const credential = GoogleAuthProvider.credentialFromError(error);
      // ...
      this.userModel = null as any;
      this.isLoggedIn = false;
      onFail();
    });

    if (this.userModel) {
      await this.RegisterUser(this.userModel.uuid,
        {
          displayName: this.userModel.displayName,
          photoURL: this.userModel.photoURL,
          email: this.userModel.email
        }).then(result => {
          if (result) {
            this.userModel = result;
          }
        });
    }
  }

  //#region Account Management
  public static async SendPasswordResetEmail(email: string): Promise<void>
  {
    let successSend = false;
    let url = `${HttpsHandler.BASE_URL}/${HttpsActionNames.ON_SEND_PASWORD_RESET_EMAIL}?email=${email}`
    await HttpsHandler.SendGetRequest(url, false, (success, data, message) => {
      if (success)
        successSend = true;
    }, (success, message) => {
    });

    if (successSend)
    {
      let payload: Map<string, any> = new Map<string, any>();
      payload.set("email", email);
      Analytics.SendAnalyticsEvent(AnalyticsId.FORGOT_PASSWORD, payload, true);
      return Promise.resolve();
    } else
      return Promise.reject();
  }

  public static async SendEmailVerificationEmail(): Promise<void>
  {
    let successSend = false;
    
    let url = `${HttpsHandler.BASE_URL}/${HttpsActionNames.ON_SEND_EMAIL_VERIFICATION_EMAIL}?email=${this.userModel.email}`;
    await HttpsHandler.SendGetRequest(url, false, (success, data, message) => {
      if (success)
        successSend = true;
    }, (success, message) => {

    });

    if (successSend)
      return Promise.resolve();
    else
      return Promise.reject();
  }

  public static CheckEmailVerificationStatus(): boolean
  {
    const auth = getAuth();

    if (auth.currentUser) {
      return auth.currentUser?.emailVerified;
    }
    else {
      return false;
    }
  }

  public static async TrySendEmailVerificationRewards(): Promise<any>
  {
    let emailVerified = this.CheckEmailVerificationStatus();

    let success = false;
    // console.log(`Verify - Name: ${this.userModel.displayName} | RR: ${this.userModel.verificationRewardsReceived}`);
    if (emailVerified && this.userModel && !this.userModel.verificationRewardsReceived)
    {
      await this.AddCredits(14).then(async () => {
        const firestore = getFirestore();
        let usersRef = collection(firestore, "users");
        let userDoc = doc(usersRef, this.userModel?.uuid)

        let params = {
          verificationRewardsReceived: true
        }
        
        await updateDoc(userDoc, params).then( async () => {
          await this.GetUserAccount(this.Model?.uuid).then((model) => {
            success = true;
          });
        })
      })
    } else {
      success = true;
      // // console.log("Email is Not Verified or Verification Rewards have been Received");
    }

    if (success)
      return Promise.resolve();
    else
      return Promise.reject();
  }

  public static async VerifyPassword(password: string): Promise<boolean>
  {
    const auth = getAuth();
    let success = false;
    await signInWithEmailAndPassword(auth, User.Model?.email, password).then((userCredential) => {
      if (userCredential) 
      {
        success = true;
      }
    });

    if (success)
      return Promise.resolve(success);
    else
      return Promise.reject(false);
  }

  private static async ReaunthenticateUser(password: string): Promise<void>
  {
    const auth = getAuth();
    const user = auth.currentUser;

    let success = false;
    let errorMessage = "";
    if (user && user.email)
    {
      const credential = EmailAuthProvider.credential(user.email, password);
    
      await reauthenticateWithCredential(user, credential).then(() => {
        success = true;
      }).catch((error) => {
        errorMessage = "Failed to Reaunthenticate User";
      });
    } else {
      errorMessage = "User does not Exist";
    }

    if (success)
      return Promise.resolve();
    else
      return Promise.reject(errorMessage)
  }

  public static async UpdateEmail(newEmail: string): Promise<any>
  {
    let success = false;
    let errorMessage = "";
    const auth = getAuth();
    const user = auth.currentUser;
  
    if (user)
    {
      await updateEmail(user, newEmail).then(async () => {
        let params = {
          email: newEmail,
        }
        await this.UpdateUserAccount(User.Model?.uuid, params).then(() => {
          success = true;
        }).catch((err) => {
          errorMessage = "Failed to update Email"
        })
      }).catch(() => {
        errorMessage = "Failed to update Email"
      });
    } else {
      errorMessage = "User does not Exist";
    }
    

    if (success) 
    {
      return Promise.resolve();
    } else
      return Promise.reject(new Error(errorMessage));
  }

  public static async UpdatePassword(password: string, newPassword: string): Promise<boolean>
  {
    let success = false;
    let errorMessage = "";
    await this.ReaunthenticateUser(password).then(async () => {
      const auth = getAuth();
      const user = auth.currentUser;

      if (user)
      {
        await updatePassword(user, newPassword).then(() => {
          success = true;
        }).catch(() => {
          errorMessage = "Failed to update Password"
        });
      } else 
      {
        errorMessage = "User does not Exist";
      }
    }).catch((err) => {
      errorMessage = err;
    });

    if (success)
      return Promise.resolve(true);
    else
      return Promise.reject(errorMessage);
  }

  public static async DeleteEmailAndPassUser(password: string): Promise<boolean>
  {
    let success = false;
    let errorMessage = "";

    await this.ReaunthenticateUser(password).then(async () => {
      const auth = getAuth();
      const user = auth.currentUser;
      
      if (user)
      {
        await deleteUser(user).then(async () => {
          await this.DeleteUser(user.uid).then(() => {
            success = true;
          }).catch((err) => {
            errorMessage = err;
          });
        }).catch(() => {
          errorMessage = "Failed to Delete User Account";
        });
      } else {
        errorMessage = "User does not Exist";
      }
    }).catch((err) => {
      errorMessage = err;
    })

    if (success)
      return Promise.resolve(success);
    else
      return Promise.reject(errorMessage);
  }

  public static async UpdateUserAccount(uuid: string, params: any): Promise<void> {
    const firestore = getFirestore();
    const usersRef = collection(firestore, "users");
    const usersDoc = doc(usersRef, uuid);
    //params = this.CheckValidDataInput(params);
    let success = false;
    let errorMessage = "";
    await updateDoc(usersDoc, params).then(() => {
      success = true;
    }).catch((err) => {
      errorMessage = err;
    });

    if (success)
      return Promise.resolve();
    else 
      return Promise.reject(errorMessage);
  }
  //#endregion

  public static async SignOut(): Promise<void> {
    const auth = getAuth();
    SessionHandler.DeleteItem('SESSION_USER_MODEL')
    let success = false;
    await Presence.Disconnect();
    await auth.signOut().then(() => {
      success = true;
    })
    this.userModel = null as any;
    this.isLoggedIn = false;
    
    if (success)
      return Promise.resolve();
    else  
      return Promise.reject();
  }

  public static async GetUsers(uuidList: string[]): Promise<Map<string, UserModel>> {
    let cache: Map<string, UserModel> = new Map<string, UserModel>();
    for (let i = 0; i < uuidList.length; i++) {
      let uuid = uuidList[i];
      await this.GetUserAccount(uuid).then((result) => {
        cache?.set(result.uuid, result);
      })
    }

    return Promise.resolve(cache);
    //return cache!;
  }

  public static async SignUp(email: string, password: string, displayName: string, fn: () => void | null): Promise<void> {
    const auth = getAuth();
    displayName = displayName.replace(/\s+/g, ' ');
    await createUserWithEmailAndPassword(auth, email, password).then(async (userCredential) => {
      const user = userCredential.user;

      this.userModel = new UserModel(
        {
          uuid: user.uid,
          //token : user.accessToken,
          displayName: displayName,
          photoURL: "",
          email: user.email
        }
      );

      if (this.userModel) {
        await this.RegisterUser(this.userModel.uuid,
          {
            displayName: this.userModel.displayName,
            photoURL: this.userModel.photoURL,
            email: this.userModel.email
          }).then(result => {
            if (result) {
              this.userModel = result;
              Mail.SendCredentialsSentEmail(password).then(() => {
              })
            }
          });
      }
      this.isLoggedIn = true;
      fn();
    }).catch((error) => {
      const errorCode = error.code;
      const errorMessage = error.message;
      this.isLoggedIn = false;
    });
  }

  private static async RegisterUser(uuid: string, params: any): Promise<UserModel> {
    let userModel: UserModel = null as any;
    await this.GetUserAccount(uuid).then(result => {
      userModel = result;
    });

    if (userModel) {
      let timeStamp = serverTimestamp();
      const updateParam = {
        lastLoggedIn: timeStamp
      };
      await this.UpdateUserAccount(uuid, updateParam);
    }
    else {
      await this.CreateUserAccount(uuid, params);
    }
    return Promise.resolve(userModel);
  }

  private static async DeleteUser(uuid: string) : Promise<void>
  {
    const firestore = getFirestore();
    const usersRef = collection(firestore, "users");
    const userDoc = doc(usersRef, uuid);

    let success = false;
    let errorMessage = "";
    await deleteDoc(userDoc).then(() => {
      success = true;
    }).catch(() => {
      errorMessage = "Failed to delete User Account"
    });

    if (success)
      return Promise.resolve();
    else
      return Promise.reject(errorMessage);
  }

  private static async CreateUserAccount(uuid: string, params: any): Promise<void> {
    let timeStamp = serverTimestamp();
    params = this.CheckValidDataInput(params);
    params["uuid"] = uuid;
    params["createdAt"] = timeStamp;
    params["lastLoggedIn"] = timeStamp;
    params["siteOfOrigin"] = window.location.hostname;
    const firestore = getFirestore();
    const usersRef = collection(firestore, "users");
    const usersDoc = doc(usersRef, uuid);
    await setDoc(usersDoc, params).then(async () => {
      await Count.IncrementCount(CountTypes.USER, 1);
      
    });

    return Promise.resolve();
  }

  public static async GetUserAccount(uuid: string): Promise<UserModel> {
    const firestore = getFirestore();
    const userDoc = doc(firestore, "users", uuid);
    const userSnap = await getDoc(userDoc);
    if (userSnap.exists()) {
      let data = userSnap.data();

      let userModel = Utils.ParseDataToUserModel(data);
      
      if (this.userModel)
      {
        if (userModel.uuid === this.userModel.uuid)
        {
          this.userModel = userModel;
          SessionHandler.SetItem(SessionKeys.SESSION_USER_MODEL, this.userModel);
        }
      }

      return Promise.resolve(userModel);
    }
    else {
      return Promise.resolve(null as any);
    }
  }

  public static async GetUserByName(username: string): Promise<UserModel> 
  {
    const firestore = getFirestore();
    const userRef = collection(firestore, "users");
    const userQuery = query(userRef, where("displayName", "==", username));

    const userSnap = await getDocs(userQuery);

    let userData: UserModel = null as any;
    // console.log(`User Snap Size: ${userSnap.size}`);
    if (userSnap.size > 0)
    {
      let user = userSnap.docs[0];
      const data = user.data();
      if (data)
        userData = Utils.ParseDataToUserModel(data);
      // console.log(`User Data Name: ${userData?.displayName} | Email: ${userData?.email}`);
    }
    
    // console.log(`Returned User Data: ${userData}`)
    return Promise.resolve(userData);
  }

  //#region Images
  public static async ModifyProfilePhoto(name: string, file: any, onDone: () => void | null, onFail: () => void | null): Promise<void>
  {
    let filePath = `${this.BASE_USER_IMAGE_DIRECTORY}/${this.PROFILE_PHOTO_PATH}/${name}`

    await FileHandler.RestrictImageSize(file, -1, async (image) => {
      if (image) {
        await FileHandler.UploadImage(image, filePath, async (url) => {
          let params = {
            photoURL: url,
            profileReference: filePath
          }
          
          await this.UpdateUserAccount(this.userModel.uuid, params).then(() => {
            onDone();     
          });
        }, (error, message) => {
          onFail();
        })
      }
    })
  }

  public static async UpdateOnlineStatus(status: boolean): Promise<void>
  {
    const firestore = getFirestore();
    let usersRef = collection(firestore, "users");
    let userDoc = doc(usersRef, User.Model?.uuid);

    let params = {
      onlineStatus: status
    }

    let success = false;
    await updateDoc(userDoc, params).then(() => {
      success = true;
    });

    if (success)
      return Promise.resolve();
    else
      return Promise.reject();
  }

  public static async AddToLikedProfiles(profileId: string): Promise<void>
  {
    const firestore = getFirestore();
    let usersRef = collection(firestore, "users");
    let userDoc = doc(usersRef, User.Model?.uuid);

    let params = {
      likedProfiles: arrayUnion(profileId)
    }

    let success = false;
    await updateDoc(userDoc, params).then(() => {
      success = true;
    });

    if (success)
      return Promise.resolve();
    else
      return Promise.reject();
  }

  public static async AddUserImage(url: string, reference: string, imageType: string): Promise<void> {
    const firestore = getFirestore();
    let currTime = serverTimestamp();
    let imageData = {
      userId: User.Model?.uuid,
      photoURL: url,
      reference: reference,
      uploadedAt: currTime,
      imageType: imageType
    }
    let imagesRef = collection(firestore, `users/${User.Model?.uuid}/images`);

    let success = false;
    await addDoc(imagesRef, imageData).then(() => {
      success = true;
    });

    if (success)
      return Promise.resolve();
  }

  public static async AddUserImages(files: any[], imageType: "public" | "private", onCompleted: () => void | null, onFailure: () => void | null)
  {
    let fileDirect = imageType === "private" ? this.PRIVATE_IMAGES_PATH : this.PUBLIC_IMAGES_PATH;
    
    let doneCount = 0;

    let readers: any[] = [];

    files.forEach((file, index) => {
      let fileName = file.name;
      let fileDetails = fileName.split('.');
      let newName = fileDetails[0]+Utils.GenerateRandomID()+'.'+fileDetails[1];
      let filePath = `${this.BASE_USER_IMAGE_DIRECTORY}/${fileDirect}/${newName}`

      let uploadToFirestore = async () => {
        await FileHandler.RestrictImageSize(file, -1, async (image) => {
          if (image) {
            await FileHandler.UploadImage(image, filePath, async (url) => {
              await this.AddUserImage(url, filePath, imageType).then(() => {
                doneCount++;
              });
            }, (error, message) => {
            })
          }
        })
      }

      readers.push(uploadToFirestore());
    })

    const checkForImages = () => {
      if (doneCount !== files.length)
        setTimeout(checkForImages, 100);
      else
        onCompleted();
    }

    Promise.all(readers).then(() => {
      checkForImages();
    }).catch(() => {
      onFailure();
    })
  }

  public static async DeleteUserImage(imageId: string): Promise<void> {
    let path = `users/${User.Model?.uuid}/images`
    const firestore = getFirestore();
    const imagesRef = collection(firestore, path);
    const imageDoc = doc(imagesRef, imageId);

    let success = false
    await deleteDoc(imageDoc).then(() => {
      success = true;
    });

    if (success)
      return Promise.resolve();
  }

  public static async GetAllUserImages(imageType: string = null as any): Promise<UserImageModel[]>
  {
    let path = `users/${User.Model?.uuid}/images`;
    const firestore = getFirestore();
    const imagesRef = collection(firestore, path);
    const imagesQuery = imageType ? query(imagesRef, orderBy("uploadedAt"), where("imageType", "==", imageType)) : query(imagesRef, orderBy("uploadedAt"));

    let images: UserImageModel[] = [];
    const imagesSnap = await getDocs(imagesQuery);

    for (let i = 0; i < imagesSnap.size; i++) {
      let image = imagesSnap.docs[i];
      const data = image.data();
      if (data) {

        let info: ImageModel = {
          id: image.id,
          ownerId: User.Model?.uuid,
          photoURL: data.photoURL,
          altURL: data.altURL,
          uploadedAt: data.uploadedAt,
          reference: data.reference,
          type: data.imageType,
        }

        let imageData: UserImageModel = {
          info: info
        }
        images.push(imageData);
      }
    }

    return Promise.resolve(images);
  }

  public static async GetAllUserImagesOnlyIDs(imageType: string = null as any): Promise<string[]> {
    let path = `users/${User.Model?.uuid}/images`;
    const firestore = getFirestore();
    const imagesRef = collection(firestore, path);
    const imagesQuery = imageType ? query(imagesRef, orderBy("uploadedAt"), where("imageType", "==", imageType)) : query(imagesRef, orderBy("uploadedAt"));

    let images: string[] = [];
    const imagesSnap = await getDocs(imagesQuery);
    for (let i = 0; i < imagesSnap.size; i++) {
      let image = imagesSnap.docs[i];
      const data = image.data();
      if (data) {
        images.push(image.id);
      }
    }

    return Promise.resolve(images);
  }
  //#endregion

  public static async GetAllUserIDs(): Promise<string[]> {
    const firestore = getFirestore();
    let usersRef = collection(firestore, "users");
    let usersQuery = query(usersRef);

    let ids: string[] = [];
    const usersSnap = await getDocs(usersQuery);
    usersSnap.forEach((user) => {
      ids.push(user.id);
    });
    return Promise.resolve(ids);
  }

  public static async GetCredits(): Promise<number>
  {
    const firestore = getFirestore();
    const usersRef = collection(firestore, "users");
    const userDoc = doc(usersRef, User.Model?.uuid);

    const userSnap = await getDoc(userDoc);
    let credits = 21;
    const data = userSnap.data();
    if (data)
    {
      if (data.credits)
        credits = data.credits;
      else
        credits = 0;
    }

    this.userModel.credits = credits;
    return Promise.resolve(credits);
  }

  public static async AddCredits(creditsToAdd: number): Promise<number>
  {
    const firestore = getFirestore();
    const usersRef = collection(firestore, "users");
    const userDoc = doc(usersRef, User.Model.uuid);
    // console.log("Adding Credits");
    let success = false;
    let newCredits = 0
    await this.GetCredits().then(async (credits) => {
      newCredits = credits + creditsToAdd;
      let params = {
        credits: newCredits
      }

      await updateDoc(userDoc, params).then(() => {
        success = true;
      });
    })

    this.userModel.credits = newCredits;

    if (success)
      return Promise.resolve(newCredits);
    else
      return Promise.reject();
  }

  public static async DeductCredits(creditsToSubtract: number): Promise<number> {
    const firestore = getFirestore();
    const usersRef = collection(firestore, "users");
    const userDoc = doc(usersRef, User.Model.uuid);

    let success = false;
    let newCredits = 0;
    await this.GetCredits().then(async (credits) => {
      if (credits >= creditsToSubtract)
      {
        newCredits = credits - creditsToSubtract;
        let params = {
          credits: newCredits
        }

        await updateDoc(userDoc, params).then(() => {
          success = true;
        });
      }
    })

    this.userModel.credits = newCredits;

    if (success)
      return Promise.resolve(newCredits);
    else
      return Promise.reject();
  }

  //#region Discount Related
  public static async AddToAvailedDiscounts(userId: string, discountRef: string): Promise<void>
  {
    const firestore = getFirestore();
    const usersRef = collection(firestore, "users");
    const userDoc = doc(usersRef, userId)

    let params = {
      availedDiscounts: arrayUnion(discountRef),
    }

    let success = false;
    await updateDoc(userDoc, params).then(() => {
      success = true;
      if (!this.userModel.availedDiscounts.includes(discountRef))
        this.userModel.availedDiscounts.push(discountRef);
    });

    if (success)
      return Promise.resolve();
    else
      return Promise.reject();
  }
  //#endregion

  private static CheckValidDataInput(params: any): any {
    const allowedData: string[] =
      [
        "uuid",
        "createdAt",
        "displayName",
        "email",
        "lastLoggedIn",
        "photoURL",
        "birthday",
        "weight",
        "height",
        "ethnicity",
        "hairColor",
        "eyeColor",
        "aboutMe",
        "lookingFor",
        "country",
        "gender",
        "maritalStatus",
        "sexualOrientation",
        "profileReference",
        "geolocation"
      ]
    let filteredData: any = {};

    allowedData.forEach(element => {
      if (element in params) {
        filteredData[element] = params[element];
      }
    });

    return filteredData;
  }
}